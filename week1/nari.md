# 🧩 Agentic Patterns Overview

---

## **Chapter 1. Prompt Chaining**
### 🔹 개념: 순차 실행
**핵심 아이디어:**  
복잡한 문제를 더 작고 관리 가능한 **하위 문제들의 시퀀스(sequence)**로 분해하는 접근.  
각 하위 문제는 별도의 프롬프트로 처리되며, 한 단계의 출력이 다음 단계의 입력으로 전달됨.

**장점:**  
- 이해 용이  
- 디버깅이 쉬움  
- 단계별 모듈화 및 명확성 향상  

### 💡 예시 (Pipeline / Chained 접근)
1. **요약 단계**  
   > “다음 시장 조사 보고서의 주요 결과를 요약하라: [text]”  
   모델의 초점이 명확히 요약에만 맞춰져 정확성이 향상됨.

2. **트렌드 식별 단계**  
   > “요약을 사용하여 상위 세 가지 신흥 트렌드를 식별하고 각 트렌드를 뒷받침하는 구체적인 데이터 포인트를 추출하라: [1단계 출력]”  
   검증된 요약을 기반으로 트렌드 도출.

3. **이메일 작성 단계**  
   > “다음 트렌드와 지원 데이터를 개략적으로 설명하는 마케팅 팀용 이메일 초안을 작성하라: [2단계 출력]”

### ⚙️ 구조화된 출력
Prompt chain의 신뢰성은 단계 간 데이터의 **무결성**에 달려 있음.  
→ `JSON` 또는 `XML` 등 **구조화된 출력 형식 지정**이 중요.

---

## **Chapter 2. Routing**
### 🔹 개념: 동적 경로 선택
Routing은 agent가 조건에 따라 **워크플로우의 다음 단계**를 동적으로 결정하도록 하는 패턴.

**Agent의 역할:**  
입력을 분석하고, 의도(intent)에 따라 다른 sub-agent 또는 chain으로 라우팅함.

### 💡 예시
- 의도 `"주문 상태 확인"` → 주문 DB와 상호작용하는 sub-agent로 route  
- 의도 `"제품 정보"` → 제품 카탈로그 검색 sub-agent로 route  
- 의도 `"기술 지원"` → 문제 해결 가이드 또는 human escalation chain으로 route  
- 의도가 불명확 → 명확화 sub-agent로 route  

### ⚙️ 구현
Routing 로직은 다음 방법으로 구현 가능:
- LLM 기반 결정  
- 규칙 기반 시스템  
- 임베딩 유사도 기반 매칭  

**관련 프레임워크**
- **LangGraph:** 복잡한 routing 로직이 있는 다단계 워크플로우에 이상적  
- **Google ADK:** 잘 정의된 Tool 세트를 가진 간단한 agent에 적합  

---

## **Chapter 3. Parallelization**
### 🔹 개념: 동시 작업 실행
**핵심 아이디어:**  
다른 부분의 출력에 의존하지 않는 워크플로우를 **parallel**로 실행.

### ⚙️ 구현
- 비동기 실행(`async`)
- 멀티스레딩 / 멀티프로세싱
- LangChain, LangGraph, Google ADK 등의 프레임워크 활용 가능

### 💡 효과
- 여러 독립 조회나 외부 API 호출을 동시에 처리 가능  
- 효율성 및 응답성 향상  
- 복잡한 agent 워크플로우의 **성능 최적화 핵심 기법**

---

## **Chapter 4. Reflection**
### 🔹 개념: 자기 평가 및 정제 루프
정교한 워크플로우라도 agent의 초기 출력이 항상 최적은 아님.  
→ **Reflection 패턴**은 agent가 자신의 출력이나 내부 상태를 평가하고 개선하도록 함.

### ⚙️ 프로세스
1. **실행:** 초기 출력 생성  
2. **평가/비평:** 결과 분석 (정확성, 일관성, 완전성 등 평가)  
3. **정제:** 개선 방법 결정 및 수정  
4. **반복:** 만족할 때까지 반복 수행 가능  

### 💡 구현 팁
- **Producer–Critic 구조** 사용
  - **Producer Agent:** 콘텐츠 생성 (예: 코드, 글, 계획 등)
  - **Critic Agent:** 평가 전담 (정확성, 품질, 스타일 검토 등)
- 서로 다른 프롬프트나 페르소나를 부여해 **편향 최소화**

### 📈 장점
- 메모리를 유지하는 agent에서는 평가 컨텍스트 축적으로 더 정교한 개선 가능  
- 피드백 루프를 통해 지속적 학습과 품질 향상

### ⚠️ 단점
- 반복 실행으로 **비용 및 지연시간 증가**  
- 메모리 및 히스토리 관리 부담 존재

---

## **Chapter 5. Tool Use**
### 🔹 개념: 외부 기능 호출 (Function / Tool Calling)
**핵심 아이디어:**  
LLM이 외부 API, DB, 서비스와 상호작용하거나 코드를 실행할 수 있도록 하는 메커니즘.

> LLM의 추론 능력 ↔ 외부 기능 간의 간극을 메우는 기술

### ⚙️ 프로세스
1. **Tool 정의:** 함수의 목적, 이름, 파라미터 타입 및 설명 제공  
2. **LLM 판단:** 요청을 분석하고 적절한 tool 호출 필요 여부 결정  
3. **Function Call 생성:** 호출할 tool명 + 파라미터를 구조화된 형태(JSON 등)로 생성  
4. **Tool 실행:** 오케스트레이션 레이어가 실제 함수 실행  
5. **결과 반환:** 실행 결과를 agent에 전달  
6. **LLM 후처리:** 결과를 이용해 후속 단계 결정 또는 최종 응답 구성  

### 💡 의미
“Function Calling”보다 “Tool Use”로 사고하면  
Agent가 다양한 디지털 리소스와 **지능적 개체의 생태계에서 오케스트레이터**로 작동하는 잠재력을 포착할 수 있음.
